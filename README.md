

## 1. Постановка задачи
Целью работы является реализация и исследование вероятностного алгоритма **HyperLogLog (HLL)** для оценки кардинальности (количества уникальных элементов $F_0$) в потоке данных. 

Необходимо:
1. Реализовать генератор потока данных и хеш-функцию.
2. Реализовать алгоритм HyperLogLog.
3. Провести серию экспериментов для оценки точности $N_t$ и дисперсии.
4. Сравнить практическую погрешность с теоретическими границами ($1.04/\sqrt{m}$ и $1.3/\sqrt{m}$).

## 2. Инфраструктура (Этап 1)

### 2.1. Генерация потока
Разработан класс `RandomStreamGen` на языке **C++**.
* **Данные:** Случайные строки длиной от 5 до 30 символов.
* **Алфавит:** `[a-z, A-Z, 0-9, -]`.
* **Параметры:** Поток разбивается на части (шаги) для моделирования изменения кардинальности во времени.

### 2.2. Хеш-функция
Использована реализация **MurmurHash3 (32-bit)**.

**Обоснование выбора:**
1. **Лавинный эффект:** MurmurHash3 обеспечивает качественное (псевдослучайное) распределение битов. Изменение одного символа во входной строке меняет ~50% битов хеша, что критически важно для корректного вычисления ранга (количества ведущих нулей).
2. **Скорость:** Это некриптографическая функция, оптимизированная для высокой производительности.
3. **Отсутствие смещения:** Функция проходит тесты SMHasher, подтверждая равномерное распределение значений по всему диапазону $2^{32}$.

---

## 3. Реализация алгоритма (Этап 2)

### 3.1. Параметры HyperLogLog
* **Число бит индекса ($b$):** 12.
* **Число регистров ($m$):** $2^{12} = 4096$.
* **Размер регистра:** 8 бит (`uint8_t`), так как максимальный возможный ранг для 32-битного хеша $\le 32$.

**Обоснование выбора $b=12$:**
* **Память:** Структура занимает $4096 \times 1 \text{ байт} = 4 \text{ КБ}$. Это экстремально малый объем, помещающийся в L1 кэш процессора.
* **Точность:** Теоретическая стандартная ошибка составляет:
  $$SE = \frac{1.04}{\sqrt{m}} = \frac{1.04}{64} \approx 1.625\%$$
  Это оптимальный баланс между потреблением памяти и точностью для задач потоковой аналитики.

### 3.2. Детали реализации
* Использована формула гармонического среднего для вычисления "сырой" оценки $E$.
* Реализована **коррекция смещения (Bias Correction)**:
  * **Linear Counting:** Применяется, когда $E \le \frac{5}{2}m$. Позволяет существенно повысить точность на малых кардинальностях.
  * **Large Range Correction:** Применяется при приближении к $2^{32}$ (учет коллизий хеш-функции).

---

## 4. Результаты экспериментов (Этап 3)

Проведено **20 независимых запусков** алгоритма на потоках объемом до 100,000 элементов. Статистика обработана с помощью Python (Pandas, Matplotlib).

### График №1: Сравнение оценки и истинного значения
<img width="1453" height="448" alt="Снимок экрана 2026-02-08 в 22 57 29" src="https://github.com/user-attachments/assets/3a65041f-a831-40dd-bf50-92bd5f4bd607" />



**Анализ:**
График демонстрирует, что оценка HyperLogLog (пунктирная линия) следует за истинным значением (сплошная линия) с высокой точностью. Благодаря переключению на алгоритм *Linear Counting* при малом заполнении регистров, ошибка в начале потока минимальна.

### График №2: Статистика и теоретические границы
<img width="1470" height="452" alt="Снимок экрана 2026-02-08 в 22 58 14" src="https://github.com/user-attachments/assets/5ac01eab-f82a-4992-a8a2-a6a2b70ad37f" />



**Анализ точности и дисперсии:**
На графике отображена средняя оценка $\mathbb{E}(N_t)$, закрашенная область стандартного отклонения $\pm \sigma$ и теоретические границы ошибок.

1. **Стабильность:** Область $\sigma$ (синяя заливка) показывает, насколько варьируется оценка между запусками. Ширина этой области невелика, что говорит о стабильности алгоритма.
2. **Соответствие теории:**
   * **Граница $1.04/\sqrt{m}$ (зеленая линия):** Большинство усредненных значений лежит внутри этого коридора.
   * **Граница $1.3/\sqrt{m}$ (красная линия):** Практически 100% экспериментальных данных укладываются в этот расширенный диапазон (соответствует доверительному интервалу ~99%).

---

## 5. Выводы

В ходе лабораторной работы был реализован алгоритм HyperLogLog с параметром $b=12$.

1. **Эффективность:** Алгоритм использует фиксированный объем памяти (**4 КБ**) для подсчета любого количества уникальных элементов (до $2^{32}$).
2. **Точность:** Экспериментальная относительная ошибка соответствует теоретическому ожиданию $\approx 1.6\%$.
3. **Модификации:** Применение *Linear Counting* является обязательным для корректной работы на малых объемах данных. Без него ошибка при $N < m$ была бы неприемлемо высокой.

HyperLogLog доказал свою эффективность как инструмент для приближенного подсчета уникальных элементов в условиях ограниченной памяти.

---

## Приложение: Инструкция по запуску

Для воспроизведения результатов:

1. **Компиляция C++ (Генерация данных):**
   ```bash
   g++ main.cpp -o hll_app```
2. **Запуск симуляции (сохранение в CSV):**
   ```bash
   g./hll_app > results.csv```
3.**Визуализация (Python):**
  ```bash
   # Предварительно установить зависимости: pip install pandas matplotlib numpy
python3 1.py(или python 1.py)```
